# Replace the "Wait for Spring Boot application" step with this more flexible version:
- name: Wait for Spring Boot application (flexible health check)
  run: |
    echo "Waiting for Spring Boot application to be ready..."
    timeout=180
    counter=0
    
    while [ $counter -lt $timeout ]; do
      # Check if container is still running
      if ! docker ps --format "{{.Names}}" | grep -q "blog-backend"; then
        echo "❌ Spring Boot container (blog-backend) is not running!"
        docker compose logs spring-app
        exit 1
      fi
    
      # Try multiple health check approaches in order of preference
      if curl -f -s http://localhost:8081/actuator/health >/dev/null 2>&1; then
        echo "✅ Spring Boot actuator health endpoint is ready!"
        break
      elif curl -f -s http://localhost:8081/actuator/info >/dev/null 2>&1; then
        echo "✅ Spring Boot actuator info endpoint is ready!"
        break
      elif curl -s http://localhost:8081/ >/dev/null 2>&1; then
        # Just check if any response (even 404 is fine for a running app)
        echo "✅ Spring Boot application is responding (any status)!"
        break
      elif nc -z localhost 8081 >/dev/null 2>&1; then
        # Last resort - just check if port is open
        echo "✅ Spring Boot application port 8081 is responding!"
        break
      fi
    
      echo "⏳ Spring Boot app not ready yet, waiting... ($counter/$timeout)"
      sleep 5
      counter=$((counter + 5))
    done
    
    if [ $counter -ge $timeout ]; then
      echo "❌ Spring Boot application failed to respond within $timeout seconds"
      echo "📋 Final container status and logs:"
      docker ps -a
      docker compose logs spring-app
      exit 1
    fi