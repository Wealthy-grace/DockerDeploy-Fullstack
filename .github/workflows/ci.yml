name: CI with Docker Compose (MySQL)

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main, develop ]

jobs:
  build-and-test:
    runs-on: ubuntu-latest

    steps:
      # 1ï¸âƒ£ Checkout repository
      - name: Checkout repository
        uses: actions/checkout@v4

      # 2ï¸âƒ£ Set up Docker Buildx
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      # 3ï¸âƒ£ Create directories for test artifacts
      - name: Create test directories
        run: |
          mkdir -p ./build/reports/tests/test
          mkdir -p ./build/test-results/test

      # 4ï¸âƒ£ Build and start Docker Compose services
      - name: Build and start Docker Compose services
        run: |
          docker compose up --build -d
          echo "Waiting for database and app containers to start..."
          sleep 20

      # 5ï¸âƒ£ Check container status
      - name: Check container status
        run: |
          echo "ğŸ” Checking container status..."
          docker ps -a
          echo "ğŸ” Docker Compose services:"
          docker compose ps

      # 6ï¸âƒ£ Wait for MySQL to be healthy
      - name: Wait for MySQL to be healthy
        run: |
          echo "Waiting for MySQL to be healthy..."
          timeout=90
          counter=0
          while [ $counter -lt $timeout ]; do
            if docker exec blog-database mysqladmin ping -h localhost -u root -pServer123@ --silent; then
              echo "âœ… MySQL is ready!"
              break
            fi
            echo "â³ MySQL not ready yet, waiting... ($counter/$timeout)"
            sleep 3
            counter=$((counter + 3))
          done
          if [ $counter -ge $timeout ]; then
            echo "âŒ MySQL failed to start within $timeout seconds"
            docker compose logs db
            exit 1
          fi

      # 7ï¸âƒ£ Check Spring Boot app logs
      - name: Check Spring Boot application logs
        run: |
          echo "ğŸ“‹ Spring Boot app logs:"
          docker compose logs spring-app
          echo "ğŸ” Container status:"
          docker ps -a

      # 8ï¸âƒ£ Wait for Spring Boot (blog-backend) container
      - name: Wait for Spring Boot application
        run: |
          echo "Waiting for Spring Boot application to be ready..."
          timeout=180
          counter=0
          while [ $counter -lt $timeout ]; do
            if ! docker ps --format "{{.Names}}" | grep -q "blog-backend"; then
              echo "âŒ Spring Boot container is not running!"
              docker compose logs spring-app
              exit 1
            fi
            if curl -f -s http://localhost:8081/actuator/health >/dev/null 2>&1 || \
               curl -f -s http://localhost:8081/ >/dev/null 2>&1 || \
               docker exec blog-backend curl -f -s http://localhost:8081/actuator/health >/dev/null 2>&1; then
              echo "âœ… Spring Boot application is ready!"
              break
            fi
            echo "â³ Spring Boot app not ready yet, waiting... ($counter/$timeout)"
            sleep 5
            counter=$((counter + 5))
          done
          if [ $counter -ge $timeout ]; then
            echo "âŒ Spring Boot failed to start within $timeout seconds"
            echo "ğŸ“‹ Spring Boot logs:"
            docker compose logs spring-app
            echo "ğŸ“‹ MySQL logs:"
            docker compose logs db
            echo "ğŸ” Container status:"
            docker ps -a
            exit 1
          fi

      # 9ï¸âƒ£ Run Gradle tests inside blog-backend (if configured with gradlew)
      - name: Run Gradle build and tests
        run: |
          echo "Running Gradle build and tests..."
          if docker exec blog-backend test -f ./gradlew; then
            docker exec blog-backend chmod +x ./gradlew
            docker exec blog-backend ./gradlew clean test --no-daemon --stacktrace
          else
            echo "âŒ gradlew not found or not in project root, skipping direct test execution"
          fi

          # Copy test results if they exist
          echo "Copying test results from container..."
          docker cp blog-backend:/app/build/reports ./build/ 2>/dev/null || echo "â„¹ï¸ No reports directory found"
          docker cp blog-backend:/app/build/test-results ./build/ 2>/dev/null || echo "â„¹ï¸ No test-results directory found"

      # ğŸ”Ÿ Run minimal health/integration checks
      - name: Run health/integration checks
        run: |
          if curl -f -s http://localhost:8081/actuator/health >/dev/null; then
            echo "âœ… Health endpoint working"
          elif curl -f -s http://localhost:8081/ >/dev/null; then
            echo "âœ… Root endpoint working"
          else
            echo "âš ï¸ No standard endpoints responding; app might still be functional"
          fi

      # 1ï¸âƒ£1ï¸âƒ£ Upload test reports as artifact
      - name: Upload test reports
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: test-reports-${{ github.run_number }}
          path: |
            ./build/reports/tests/test/
            ./build/test-results/test/
          retention-days: 7

      # 1ï¸âƒ£2ï¸âƒ£ Upload application logs
      - name: Upload application logs
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: application-logs-${{ github.run_number }}
          path: |
            docker-compose-logs.txt
          retention-days: 3

      # 1ï¸âƒ£3ï¸âƒ£ Generate logs for debugging
      - name: Generate logs for debugging
        if: always()
        run: |
          docker compose logs > docker-compose-logs.txt
          echo "ğŸ” Container status:"
          docker ps -a
          echo "ğŸ” Docker images:"
          docker images

      # 1ï¸âƒ£4ï¸âƒ£ Clean up
      - name: Clean up Docker Compose
        if: always()
        run: |
          docker compose down -v --remove-orphans
          docker system prune -f

  # Optional: Deploy job
  deploy:
    needs: build-and-test
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'
    steps:
      - name: Deploy to staging/production
        run: |
          echo "ğŸš€ Deployment would happen here..."
